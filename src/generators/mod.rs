use crate::ErasureDecoder;
use crate::ParityCheckMatrix;
use crate::SimulationResult;
use crate::Simulator;
use rand::Rng;

pub trait CodeGenerator {
    /// Returns a code generated by the generator.
    fn generate<R: Rng + ?Sized>(&self, rng: &mut R) -> ParityCheckMatrix;

    /// Returns the code with the best performance among the `n_codes` generated codes. That is,
    /// the code that took the most iterations to obtain `n_failures_per_code` failures using an
    /// erausure decoder with probability `erasure_prob`.
    fn find_best_code_from_erasure<R: Rng + ?Sized>(
        &self,
        erasure_prob: f64,
        n_codes: usize,
        n_failures_per_code: usize,
        rng: &mut R,
    ) -> Option<(ParityCheckMatrix, SimulationResult)> {
        let mut best_code = None;
        let mut best_performance = SimulationResult::worse_result();
        for _ in 0..n_codes {
            let code = self.generate(rng);
            let decoder = ErasureDecoder::new(code.clone(), erasure_prob);
            let simulator = Simulator::new(decoder);
            let result = simulator.simulate_until_events_are_found(n_failures_per_code);
            if result.failure_rate() < best_performance.failure_rate() {
                best_performance = result;
                best_code = Some(code);
            }
        }
        best_code.map(|code| (code, best_performance))
    }
}

pub mod random_check_generator;
pub use random_check_generator::*;

pub mod regular_ldpc;
pub use regular_ldpc::*;

pub mod hierarchical_code;
pub use hierarchical_code::*;

pub mod increasing_range_code;
pub use increasing_range_code::*;
